<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>UEFI EFI_WIDE_GLYPH 汉字字库生成器</title>
    <!-- opentype.js - https://opentype.js.org/ -->
    <!-- The MIT License (MIT) -->
    <!-- Copyright (c) 2020 Frederik De Bleser -->
    <script src="https://opentype.js.org/dist/opentype.js"></script>
    <style>
        body { font-family: Arial, sans-serif; max-width: 900px; margin: 0 auto; padding: 20px; }
        .grid { display: grid; grid-template-columns: repeat(16, 20px); gap: 2px; margin-top: 10px; }
        .pixel { width: 20px; height: 20px; background-color: #f0f0f0; border: 1px solid #ccc; }
        .pixel.active { background-color: black; }
        textarea { width: 100%; min-height: 150px; font-family: monospace; }
        .file-input-container { margin-bottom: 20px; }
    </style>
</head>
<body>
    <h1>UEFI EFI_WIDE_GLYPH 汉字字库生成器</h1>

    <div class="file-input-container">
        <label for="fontFile">选择字体文件：</label>
        <input type="file" id="fontFile" accept=".hex,.otf,.ttf">
    </div>

    <div>
        <label for="charInput">输入汉字：</label>
        <input type="text" id="charInput" placeholder="请输入汉字" onkeypress="handleKeyPress(event)">
        <button onclick="generateGlyphs()">生成字库</button>
    </div>

    <div>
        <label for="unicodeRange">Unicode范围：</label>
        <input type="text" id="unicodeRangeStart" placeholder="起始值 (例如: 4E00)" size="16">
        <span>-</span>
        <input type="text" id="unicodeRangeEnd" placeholder="结束值 (例如: 4E10)" size="16">
        <button onclick="generateGlyphsFromRange()">生成字库</button>
    </div>

    <div>
        <h3>输出字库信息</h3>
        <textarea id="outputArea" readonly></textarea>
    </div>

    <div>
        <h3>点阵预览</h3>
        <div id="glyphPreview" class="grid"></div>
    </div>

    <script>
    let fontData = null;
    let fontType = null;

    document.getElementById('fontFile').addEventListener('change', function(e) {
        const file = e.target.files[0];
        const allowedExtensions = ['hex', 'otf', 'ttf'];
        const fileExtension = file.name.split('.').pop().toLowerCase();

        // Check if the file extension is allowed
        if (!allowedExtensions.includes(fileExtension)) {
            alert('请选择支持的字体文件类型 (.hex, .otf, .ttf)');
            // Clear the file input
            e.target.value = '';
            return;
        }

        const reader = new FileReader();

        reader.onload = function(event) {
            fontData = event.target.result;
            fontType = fileExtension;
        };

        if (fileExtension === 'hex') {
            reader.readAsText(file);
        } else {
            reader.readAsArrayBuffer(file);
        }
    });

    function extractCharacterBitmap(char) {
        if (!fontData) {
            alert('请先上传字体文件');
            return null;
        }

        const charCode = char.charCodeAt(0).toString(16).toUpperCase();

        if (fontType === 'hex') {
            // 从 HEX 文件中查找字符数据
            const lines = fontData.split('\n');
            const charLine = lines.find(line => line.startsWith(charCode + ':'));

            if (!charLine) return null;

            // 提取 HEX 数据
            const hexData = charLine.split(':')[1].replace(/\s/g, '');
            const bitmap = new Uint8Array(32);
            for (let i = 0; i < 32; i++) {
                bitmap[i] = parseInt(hexData.substr(i*2, 2), 16);
            }
            return bitmap;
        } else if (fontType === 'otf' || fontType === 'ttf') {
            try {
                const font = opentype.parse(fontData);
                const glyph = font.charToGlyph(char);
                const bitmap = new Uint8Array(32);

                // 创建一个临时的 canvas 来绘制字形
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 16;
                canvas.height = 16;
                ctx.clearRect(0, 0, 16, 16);

                // 设置绘制参数
                ctx.fillStyle = 'black';
                const path = glyph.getPath(0, 14, 16);
                path.fill = 'black';
                path.draw(ctx);

                // 获取像素数据
                const imageData = ctx.getImageData(0, 0, 16, 16);
                const pixels = imageData.data;

                // 将像素数据转换为位图格式
                let byteIndex = 0;
                for (let y = 0; y < 16; y++) {
                    let byte1 = 0;
                    let byte2 = 0;
                    for (let x = 0; x < 16; x++) {
                        // pixels: [r, g, b, a, r, g, b, a, ...]
                        const pixelIndex = (y * 16 + x) * 4;
                        const isBlack = pixels[pixelIndex+3] === 0xff; // 检查像素是否为黑色

                        if (x < 8) {
                            byte1 |= (isBlack ? 1 : 0) << (7 - (x % 8));
                        } else {
                            byte2 |= (isBlack ? 1 : 0) << (7 - (x % 8));
                        }
                    }
                    bitmap[byteIndex++] = byte1;
                    bitmap[byteIndex++] = byte2;
                }

                return bitmap;
            } catch (error) {
                console.error('处理字体文件时出错:', error);
                return null;
            }
        } else {
            alert('不支持的字体文件');
        }

    }

    function generateGlyphs() {
        const input = document.getElementById('charInput').value;
        const outputArea = document.getElementById('outputArea');
        const glyphPreview = document.getElementById('glyphPreview');

        glyphPreview.innerHTML = '';
        outputArea.value = '';

        for (let char of input) {
            const bitmap = extractCharacterBitmap(char);

            if (!bitmap) {
                outputArea.value += `无法找到字符 ${char} 的字体数据\n`;
                continue;
            }

            const binaryData = convertToEFIWideGlyph(bitmap, char);

            outputArea.value += binaryData.fullOutput;
            let charIndex = input.indexOf(char)
            renderGlyphPreview(binaryData.glyphData, glyphPreview, charIndex);
        }
    }

    function generateGlyphsFromRange() {
        const start = parseInt(document.getElementById('unicodeRangeStart').value, 16);
        const end = parseInt(document.getElementById('unicodeRangeEnd').value, 16);

        if (isNaN(start) || isNaN(end)) {
            alert('请输入有效的Unicode范围（十六进制）');
            return;
        }

        if (start > end) {
            alert('起始值不能大于结束值');
            return;
        }

        const charCount = end - start + 1;
        const showPreview = charCount <= 10;

        const outputArea = document.getElementById('outputArea');
        const glyphPreview = document.getElementById('glyphPreview');

        glyphPreview.innerHTML = '';
        outputArea.value = '';

        let index = 0;
        for (let code = start; code <= end; code++) {
            const char = String.fromCodePoint(code);
            const bitmap = extractCharacterBitmap(char);

            if (!bitmap) {
                outputArea.value += `无法找到字符 ${char} (U+${code.toString(16).toUpperCase()}) 的字体数据\n`;
                continue;
            }

            const binaryData = convertToEFIWideGlyph(bitmap, char);
            outputArea.value += binaryData.fullOutput;

            if (showPreview) {
                renderGlyphPreview(binaryData.glyphData, glyphPreview, index);
            }
            index++;
        }

        if (!showPreview) {
            glyphPreview.innerHTML = '<p>字符数量过多，已禁用预览</p>';
        }
    }

    function convertToEFIWideGlyph(bitmap, char) {
        const extendedBitmap = extendBitmap(bitmap);

        const col1 = extendedBitmap.slice(0, 19);  // 左半部分
        const col2 = extendedBitmap.slice(19);     // 右半部分

        let fullOutput = `{0x${char.charCodeAt(0).toString(16)}, 0x00, `;

        // 第一列（左半部分）
        fullOutput += `{${col1.map(b => `0x${b.toString(16).toUpperCase().padStart(2, '0')}`).join(', ')}}, `;

        // 第二列（右半部分）
        fullOutput += `{${col2.map(b => `0x${b.toString(16).toUpperCase().padStart(2, '0')}`).join(', ')}}, `;

        // Pad
        fullOutput += `{0x00,0x00,0x00}},`;

        // Chinese
        fullOutput += ``;

        fullOutput += `        // ${char.toString()}\n`;

        return {
            fullOutput,
            glyphData: extendedBitmap
        };
    }

    function extendBitmap(bitmap) {
        const extendedBitmap = new Array(38).fill(0);

        for (let i = 0; i < 16; i++) {
            const rowHigh = bitmap[i * 2];     // 左半部分
            const rowLow = bitmap[i * 2 + 1];  // 右半部分
            extendedBitmap[i] = rowHigh;
            extendedBitmap[i + 19] = rowLow;
        }

        return extendedBitmap;
    }

    function renderGlyphPreview(glyphData, container, glyphIndex, options = {}) {
        const {
            pixelSize = 10,
            maxColumns = 5,
            gapX = 5,
            gapY = 5
        } = options;

        // 计算当前字形的位置
        const row = Math.floor(glyphIndex / maxColumns);
        const col = glyphIndex % maxColumns;

        // 如果是第一次渲染，清空容器并设置容器样式
        if (glyphIndex === 0) {
            container.innerHTML = '';
            container.style.position = 'relative';
            container.style.display = 'grid';
            container.style.gridTemplateColumns = `repeat(${maxColumns}, auto)`;
            container.style.gap = `${gapY}px ${gapX}px`;
        }

        // 创建字形容器
        const glyphContainer = document.createElement('div');
        glyphContainer.style.position = 'relative';
        glyphContainer.style.width = `${16 * pixelSize}px`;
        glyphContainer.style.height = `${19 * pixelSize}px`;

        for (let row_pixel = 0; row_pixel < 19; row_pixel++) {
            for (let col_pixel = 0; col_pixel < 16; col_pixel++) {
                const pixel = document.createElement('div');
                pixel.style.position = 'absolute';
                pixel.style.width = `${pixelSize}px`;
                pixel.style.height = `${pixelSize}px`;
                pixel.style.left = `${col_pixel * pixelSize}px`;
                pixel.style.top = `${row_pixel * pixelSize}px`;

                const byteIndex = col_pixel < 8 ? row_pixel : row_pixel + 19;
                const bitPosition = col_pixel % 8;
                const byte = glyphData[byteIndex];
                const isActive = (byte & (1 << (7 - bitPosition))) !== 0;

                pixel.classList.add('pixel');
                if (isActive) {
                    pixel.classList.add('active');
                }
                
                glyphContainer.appendChild(pixel);
            }
        }

        // 添加索引标签
        const indexLabel = document.createElement('div');
        indexLabel.textContent = `Glyph ${glyphIndex}`;
        indexLabel.style.textAlign = 'center';
        indexLabel.style.width = `${16 * pixelSize}px`;

        const wrapper = document.createElement('div');
        wrapper.appendChild(indexLabel);
        wrapper.appendChild(glyphContainer);

        container.appendChild(wrapper);
    }

    function handleKeyPress(event) {
        // 仅在光标位于输入框内时生效
        if (event.key === 'Enter' && document.activeElement.id === 'charInput') {
            // 检查是否已选择字体
            if (!fontData) {
                alert('请先上字体文件');
                return;
            }

            // 检查是否输入了汉字
            const input = document.getElementById('charInput').value;
            if (!input.trim()) {
                alert('请输入汉字');
                return;
            }

            generateGlyphs();
        }
    }

    </script>
</body>
</html>
