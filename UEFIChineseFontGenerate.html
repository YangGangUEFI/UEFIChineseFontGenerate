<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>UEFI EFI_WIDE_GLYPH 汉字字库生成器</title>
    <!-- opentype.js - https://opentype.js.org/ -->
    <!-- The MIT License (MIT) -->
    <!-- Copyright (c) 2020 Frederik De Bleser -->
    <script src="https://opentype.js.org/dist/opentype.js"></script>
    <style>
        body { font-family: Arial, sans-serif; max-width: 900px; margin: 0 auto; padding: 20px; }
        .grid { display: grid; grid-template-columns: repeat(16, 20px); gap: 2px; margin-top: 10px; }
        .pixel { width: 20px; height: 20px; background-color: #f0f0f0; border: 1px solid #ccc; }
        .pixel.active { background-color: black; }
        textarea { width: 100%; min-height: 150px; font-family: monospace; }
        .file-input-container { margin-bottom: 20px; }
    </style>
</head>
<body>
    <h1>UEFI EFI_WIDE_GLYPH 汉字字库生成器</h1>

    <div class="file-input-container">
        <label for="fontFile">选择字体文件：</label>
        <input type="file" id="fontFile" accept=".hex,.otf,.ttf">
    </div>

    <div class="input-hint">
        <p>提示：</p>
        <ul>
            <li>可以直接输入汉字，按回车键或点击"生成字库"按钮生成</li>
            <li>也可以输入Unicode范围，例如 4E00-9FFF 表示常用汉字范围</li>
            <li>Unicode范围请使用16进制数值</li>
        </ul>
    </div>
    <style>
        .input-hint {
            background: #f5f5f5;
            padding: 10px 15px;
            border-radius: 4px;
            margin-bottom: 15px;
        }
        .input-hint p {
            margin: 0 0 5px 0;
            font-weight: bold;
        }
        .input-hint ul {
            margin: 0;
            padding-left: 20px;
        }
        .input-hint li {
            margin: 3px 0;
            color: #666;
        }
    </style>
     

    <div>
        <label for="charInput">输入汉字：</label>
        <input type="text" id="charInput" placeholder="请输入汉字" onkeypress="handleKeyPress(event)">
        <button onclick="generateGlyphs()">生成字库</button>
    </div>

    <div>
        <label for="unicodeRange">Unicode范围：</label>
        <input type="text" id="unicodeRangeStart" placeholder="起始值 (例如: 4E00)" size="16">
        <span>-</span>
        <input type="text" id="unicodeRangeEnd" placeholder="结束值 (例如: 4E10)" size="16">
        <button onclick="generateGlyphsFromRange()">生成字库</button>
    </div>

    <div>
        <h3>输出字库信息</h3>
        <textarea id="outputArea" readonly></textarea>
    </div>

    <div>
        <h3>点阵预览</h3>
        <div id="glyphPreview" class="grid"></div>
    </div>

    <footer style="
        margin-top: 30px;
        padding: 20px;
        text-align: center;
        color: #666;
        border-top: 1px solid #eee;
    ">
        <p>Copyright (c) <script>document.write(new Date().getFullYear())</script>, Yang Gang</p>
        <p style="display: flex; align-items: center; justify-content: center; gap: 4px;">
            <a href="https://github.com/YangGangUEFI/UEFIChineseFontGenerate" target="_blank" style="color: #666; text-decoration: none; display: flex; align-items: center; gap: 4px;">
                <svg height="16" width="16" viewBox="0 0 16 16" style="display: inline-block;">
                    <path fill="#666" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                </svg>
                UEFIChineseFontGenerate
            </a>
        </p>
    </footer>

    <script>
    let fontData = null;
    let fontType = null;
    let parsedFont = null;

    document.getElementById('fontFile').addEventListener('change', function(e) {
        const file = e.target.files[0];
        const allowedExtensions = ['hex', 'otf', 'ttf'];
        const fileExtension = file.name.split('.').pop().toLowerCase();

        // Check if the file extension is allowed
        if (!allowedExtensions.includes(fileExtension)) {
            alert('请选择支持的字体文件类型 (.hex, .otf, .ttf)');
            // Clear the file input
            e.target.value = '';
            return;
        }

        const reader = new FileReader();

        reader.onload = function(event) {
            fontData = event.target.result;
            fontType = fileExtension;

            if (fontType === 'otf' || fontType === 'ttf') {
                try {
                    parsedFont = opentype.parse(fontData);
                } catch (error) {
                    console.error('解析字体文件时出错:', error);
                    alert('字体文件解析失败');
                }
            }
        };

        if (fileExtension === 'hex') {
            reader.readAsText(file);
        } else {
            reader.readAsArrayBuffer(file);
        }
    });

    function extractCharacterBitmap(char) {
        if (!fontData) {
            alert('请先上传字体文件');
            return null;
        }

        const charCode = char.charCodeAt(0).toString(16).toUpperCase();

        if (fontType === 'hex') {
            // 从 HEX 文件中查找字符数据
            const lines = fontData.split('\n');
            const charLine = lines.find(line => line.startsWith(charCode + ':'));

            if (!charLine) return null;

            // 提取 HEX 数据
            const hexData = charLine.split(':')[1].replace(/\s/g, '');
            const bitmap = new Uint8Array(32);
            for (let i = 0; i < 32; i++) {
                bitmap[i] = parseInt(hexData.substr(i*2, 2), 16);
            }
            return bitmap;
        } else if (fontType === 'otf' || fontType === 'ttf') {
            try {
                const glyph = parsedFont.charToGlyph(char);
                const bitmap = new Uint8Array(32);

                // 创建一个临时的 canvas 来绘制字形
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 16;
                canvas.height = 16;
                ctx.clearRect(0, 0, 16, 16);

                // 优化绘制参数
                const path = glyph.getPath(0, 14, 16);
                path.fill = 'black';

                // 使用优化的绘制方法
                ctx.fillStyle = 'black';
                path.draw(ctx);

                // 获取像素数据并优化转换过程
                const imageData = ctx.getImageData(0, 0, 16, 16);
                const pixels = imageData.data;
                const threshold = 128; // 添加阈值判断

                // 优化位图转换逻辑
                for (let y = 0; y < 16; y++) {
                    let byte1 = 0;
                    let byte2 = 0;
                    const rowOffset = y * 16 * 4;

                    for (let x = 0; x < 16; x++) {
                        const pixelIndex = rowOffset + x * 4;
                        // 使用 alpha 通道判断像素
                        const isBlack = pixels[pixelIndex + 3] > threshold;

                        if (x < 8) {
                            byte1 |= (isBlack ? 1 : 0) << (7 - x);
                        } else {
                            byte2 |= (isBlack ? 1 : 0) << (15 - x);
                        }
                    }

                    bitmap[y * 2] = byte1;
                    bitmap[y * 2 + 1] = byte2;
                }

                return bitmap;
            } catch (error) {
                console.error('处理字符时出:', error);
                return null;
            }
        } else {
            alert('不支持的字体文件');
        }

    }

    function generateGlyphs() {
        // 先检查是否已上传字体
        if (!fontData) {
            alert('请先上传字体文件');
            return;
        }

        const input = document.getElementById('charInput').value;
        if (!input.trim()) {
            alert('请输入汉字');
            return;
        }

        const outputArea = document.getElementById('outputArea');
        const glyphPreview = document.getElementById('glyphPreview');

        glyphPreview.innerHTML = '';
        outputArea.value = '';

        for (let char of input) {
            const bitmap = extractCharacterBitmap(char);

            if (!bitmap) {
                outputArea.value += `无法找到字符 ${char} 的字体数据\n`;
                continue;
            }

            const binaryData = convertToEFIWideGlyph(bitmap, char);

            outputArea.value += binaryData.fullOutput;
            let charIndex = input.indexOf(char);
            renderGlyphPreview(binaryData.glyphData, glyphPreview, charIndex);
        }
    }

    function generateGlyphsFromRange() {
        if (!fontData) {
            alert('请先上传字体文件');
            return;
        }

        const start = parseInt(document.getElementById('unicodeRangeStart').value, 16);
        const end = parseInt(document.getElementById('unicodeRangeEnd').value, 16);

        if (isNaN(start) || isNaN(end)) {
            alert('请输入有效的Unicode范围（十六进制）');
            return;
        }

        if (start > end) {
            alert('起始值不能大于结束值');
            return;
        }

        const charCount = end - start + 1;
        const showPreview = charCount <= 20;

        const outputArea = document.getElementById('outputArea');
        const glyphPreview = document.getElementById('glyphPreview');

        glyphPreview.innerHTML = '';
        outputArea.value = '';

        let index = 0;
        const processNextChar = () => {
            if (index > end - start) {
                document.body.removeChild(progressText);
                if (!showPreview) {
                    glyphPreview.style.display = 'block';
                    glyphPreview.style.width = '100%';
                    glyphPreview.innerHTML = `
                        <div style="
                            color: #666;
                            padding: 10px;
                            text-align: left;
                            width: 100%;
                            display: block;
                        ">字符数量（${charCount}个）超过20个，已禁用点阵预览</div>
                    `;
                }
                return;
            }

            const code = start + index;
            const char = String.fromCodePoint(code);
            const bitmap = extractCharacterBitmap(char);

            if (bitmap) {
                const binaryData = convertToEFIWideGlyph(bitmap, char);
                outputArea.value += binaryData.fullOutput;

                if (showPreview) {
                    renderGlyphPreview(binaryData.glyphData, glyphPreview, index);
                }
            } else {
                outputArea.value += `无法找到字符 ${char} (U+${code.toString(16).toUpperCase()}) 的字体数据\n`;
            }

            progressText.textContent = `处理进度: ${Math.floor((index / (end - start + 1)) * 100)}%`;

            index++;
            requestAnimationFrame(processNextChar);
        };

        const progressText = document.createElement('div');
        progressText.id = 'progressText';
        document.body.appendChild(progressText);

        processNextChar();
    }

    function convertToEFIWideGlyph(bitmap, char) {
        const extendedBitmap = extendBitmap(bitmap);

        const col1 = extendedBitmap.slice(0, 19);  // 左半部分
        const col2 = extendedBitmap.slice(19);     // 右半部分

        let fullOutput = `{0x${char.charCodeAt(0).toString(16)}, 0x00, `;

        // 第一列（左半部分）
        fullOutput += `{${col1.map(b => `0x${b.toString(16).toUpperCase().padStart(2, '0')}`).join(', ')}}, `;

        // 第二列（右半部分）
        fullOutput += `{${col2.map(b => `0x${b.toString(16).toUpperCase().padStart(2, '0')}`).join(', ')}}, `;

        // Pad
        fullOutput += `{0x00,0x00,0x00}},`;

        // Chinese
        fullOutput += ``;

        fullOutput += `        // ${char.toString()}\n`;

        return {
            fullOutput,
            glyphData: extendedBitmap
        };
    }

    function extendBitmap(bitmap) {
        const extendedBitmap = new Array(38).fill(0);

        for (let i = 0; i < 16; i++) {
            const rowHigh = bitmap[i * 2];     // 左半部分
            const rowLow = bitmap[i * 2 + 1];  // 右半部分
            extendedBitmap[i] = rowHigh;
            extendedBitmap[i + 19] = rowLow;
        }

        return extendedBitmap;
    }

    function renderGlyphPreview(glyphData, container, glyphIndex, options = {}) {
        const {
            pixelSize = 10,
            maxColumns = 5,
            gapX = 5,
            gapY = 5
        } = options;

        // 计算当前字形的位置
        const row = Math.floor(glyphIndex / maxColumns);
        const col = glyphIndex % maxColumns;

        // 如果是第一次渲染，清空容器并设置容器样式
        if (glyphIndex === 0) {
            container.innerHTML = '';
            container.style.position = 'relative';
            container.style.display = 'grid';
            container.style.gridTemplateColumns = `repeat(${maxColumns}, auto)`;
            container.style.gap = `${gapY}px ${gapX}px`;
        }

        // 创建字形容器
        const glyphContainer = document.createElement('div');
        glyphContainer.style.position = 'relative';
        glyphContainer.style.width = `${16 * pixelSize}px`;
        glyphContainer.style.height = `${19 * pixelSize}px`;

        for (let row_pixel = 0; row_pixel < 19; row_pixel++) {
            for (let col_pixel = 0; col_pixel < 16; col_pixel++) {
                const pixel = document.createElement('div');
                pixel.style.position = 'absolute';
                pixel.style.width = `${pixelSize}px`;
                pixel.style.height = `${pixelSize}px`;
                pixel.style.left = `${col_pixel * pixelSize}px`;
                pixel.style.top = `${row_pixel * pixelSize}px`;

                const byteIndex = col_pixel < 8 ? row_pixel : row_pixel + 19;
                const bitPosition = col_pixel % 8;
                const byte = glyphData[byteIndex];
                const isActive = (byte & (1 << (7 - bitPosition))) !== 0;

                pixel.classList.add('pixel');
                if (isActive) {
                    pixel.classList.add('active');
                }
                
                glyphContainer.appendChild(pixel);
            }
        }

        // 添加索引标签
        const indexLabel = document.createElement('div');
        indexLabel.textContent = `Glyph ${glyphIndex}`;
        indexLabel.style.textAlign = 'center';
        indexLabel.style.width = `${16 * pixelSize}px`;

        const wrapper = document.createElement('div');
        wrapper.appendChild(indexLabel);
        wrapper.appendChild(glyphContainer);

        container.appendChild(wrapper);
    }

    function handleKeyPress(event) {
        if (event.key === 'Enter' && document.activeElement.id === 'charInput') {
            // 检查是否已选择字体
            if (!fontData) {
                alert('请先上传字体文件');
                return;
            }

            // 检查是否输入了汉字
            const input = document.getElementById('charInput').value;
            if (!input.trim()) {
                alert('请输入汉字');
                return;
            }

            generateGlyphs();
        }
    }

    </script>
</body>
</html>
